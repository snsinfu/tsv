// Copyright snsinfu 2021.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef INCLUDED_SNSINFU_TSV_HPP
#define INCLUDED_SNSINFU_TSV_HPP

#include <charconv>
#include <cstddef>
#include <istream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <type_traits>
#include <utility>
#include <vector>


namespace tsv
{
    /**
     * Loads tab-separated values from each line of an input.
     *
     * @param input is a stream containing a tab-separated document.
     *
     * @returns A vector of loaded records.
     */
    template<typename Record>
    std::vector<Record> load(std::istream& input);

    template<typename Record>
    std::vector<Record> load(std::istream&& input)
    {
        return tsv::load<Record>(input);
    }

    /**
     * Base class for reporting an error when parsing an input.
     */
    class error : public std::runtime_error
    {
    public:
        using std::runtime_error::runtime_error;

        /**
         * Content of the line that caused the error, if available.
         */
        std::string line;

        /**
         * 1-based line number in an input where the error is occured. This is
         * set to zero if a line number is not available.
         */
        std::size_t line_number = 0;

        /**
         * Describes the error in detail. This function allocates memory and
         * thus can throw an exception.
         */
        std::string describe() const
        {
            std::string message = what();

            if (line_number) {
                message += " (at line ";
                message += std::to_string(line_number);
                message += ")";
            }

            if (!line.empty()) {
                message += ": \"";
                message += line;
                message += "\"";
            }

            return message;
        }
    };

    /**
     * An exception thrown when an input line has unexpected number of fields.
     */
    class format_error : public tsv::error
    {
    public:
        using tsv::error::error;

        static inline char const* const missing_field =
            "insufficient number of fields";
        static inline char const* const excess_field =
            "excess fields";
    };

    /**
     * An exception thrown when a text is not parseable as a value.
     */
    class parse_error : public tsv::error
    {
    public:
        using tsv::error::error;

        static inline char const* const unknown =
            "parse error";
        static inline char const* const out_of_range =
            "value out of range";
        static inline char const* const leftover =
            "excess character(s) at the end of a field";
    };

    /**
     * An exception thrown when reading from an input fails.
     */
    class io_error : public tsv::error
    {
    public:
        using tsv::error::error;

        static inline char const* const unknown =
            "input error";
    };

    /**
     * An exception thrown when validation fails on a record.
     */
    class validation_error : public tsv::error
    {
    public:
        using tsv::error::error;
    };

    /**
     * Throws `tsv::validation_error` if a predicate is false.
     *
     * Use `tsv::check()` function to validate the values of the fields in your
     * record structure in `validate()` member function.
     *
     * ```
     * struct my_record
     * {
     *     unsigned row;
     *     unsigned column;
     *     double value;
     *
     *     void validate() const
     *     {
     *         tsv::check(
     *             row < column,
     *             "row index must be smaller than column index"
     *         );
     *         tsv::check(value >= 0, "value must be non-negative);
     *     }
     * };
     * ```
     *
     * @param pred  The condition to test.
     * @param message  A message that describes the expected condition.
     */
    inline
    void check(bool pred, std::string const& message)
    {
        if (!pred) {
            throw tsv::validation_error{message};
        }
    }

    /**
     * Traits class for customizing how values of type T are parsed.
     */
    template<typename T>
    struct conversion;
}

// Structure member counting

namespace tsv::detail
{
    /** Dummy convertible-to-anything type used to probe structure fields. */
    struct any
    {
        template<typename T>
        operator T() const;
    };

    /**
     * Detects the number of fields in an aggregate structure Record.
     *
     * The second parameter is `std::void_t` probing an aggregate initializer.
     * The third parameter is the type list of the initializers.
     */
    template<typename Record, typename = void, typename... Inits>
    struct record_size
    {
        static constexpr std::size_t value = 0;
    };

    template<typename Record, typename... Inits>
    struct record_size<
        Record,
        std::void_t<decltype(Record{any{}, Inits{}...})>,
        Inits...
    >
    {
        static constexpr std::size_t value =
            record_size<Record, void, any, Inits...>::value + 1;
    };

    /** Detects the number of fields in an aggregate structure. */
    template<typename Record>
    inline constexpr std::size_t record_size_v = record_size<Record>::value;
}

// Structure decomposition

namespace tsv::detail
{
    /** A dummy type to hold a template type list. */
    template<typename...>
    struct type_list {};

    template<typename... Ts>
    type_list<Ts...> type_list_of(Ts const&...);

    template<std::size_t N>
    using size = std::integral_constant<std::size_t, N>;

    /** Returns a type_list of the fields of a structure. */
    template<typename Record>
    auto splat(Record const&, size<0>)
    {
        return type_list<>{};
    }

#define TSV_SPLAT(N, ...)                       \
    template<typename Record>                   \
    auto splat(Record const& record, size<N>)   \
    {                                           \
        auto [__VA_ARGS__] = record;            \
        return type_list_of(__VA_ARGS__);       \
    }

    TSV_SPLAT(1, a1)
    TSV_SPLAT(2, a1, a2)
    TSV_SPLAT(3, a1, a2, a3)
    TSV_SPLAT(4, a1, a2, a3, a4)
    TSV_SPLAT(5, a1, a2, a3, a4, a5)
    TSV_SPLAT(6, a1, a2, a3, a4, a5, a6)
    TSV_SPLAT(7, a1, a2, a3, a4, a5, a6, a7)
    TSV_SPLAT(8, a1, a2, a3, a4, a5, a6, a7, a8)
    TSV_SPLAT(9, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    TSV_SPLAT(10, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
    TSV_SPLAT(11, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
    TSV_SPLAT(12, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
    TSV_SPLAT(13, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
    TSV_SPLAT(14, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)
    TSV_SPLAT(15, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)
    TSV_SPLAT(16, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)
    TSV_SPLAT(17, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17)
    TSV_SPLAT(18, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18)
    TSV_SPLAT(19, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19)
    TSV_SPLAT(20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    TSV_SPLAT(21, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21)
    TSV_SPLAT(22, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22)
    TSV_SPLAT(23, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23)
    TSV_SPLAT(24, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24)
    TSV_SPLAT(25, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25)
    TSV_SPLAT(26, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26)
    TSV_SPLAT(27, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27)
    TSV_SPLAT(28, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28)
    TSV_SPLAT(29, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29)
    TSV_SPLAT(30, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30)
    TSV_SPLAT(31, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31)
    TSV_SPLAT(32, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32)

#undef TSV_SPLAT

    /** Returns a type_list of the fields of an aggregate structure. */
    template<typename Record>
    using field_type_list = decltype(
        splat(std::declval<Record>(), size<record_size_v<Record>>{})
    );
}

namespace tsv::detail
{
    // Basic value parsing

    /**
     * Default implementation for tsv::conversion traits defined below.
     *
     * Fallback uses stream input operator to read a value of type T from
     * a stringstream. This is slow.
     */
    template<typename T, typename = void>
    struct default_conversion
    {
        static T parse(std::string_view text)
        {
            using char_traits = std::istringstream::traits_type;

            std::istringstream stream{std::string{text}};
            T value;
            stream >> value;

            if (stream.fail() && !stream.eof()) {
                throw tsv::parse_error{tsv::parse_error::unknown};
            }

            if (stream.get() != char_traits::eof()) {
                throw tsv::parse_error{tsv::parse_error::leftover};
            }

            return value;
        }
    };

    /**
     * An optimized implementation of `default_conversion` for numeric
     * types T.
     */
    template<typename T>
    struct default_conversion<
        T,
        std::void_t<
            decltype(std::from_chars(nullptr, nullptr, std::declval<T&>()))
        >
    >
    {
        static T parse(std::string_view text)
        {
            auto const begin = text.data();
            auto const end = text.data() + text.size();

            T value;
            auto const [remain, ec] = std::from_chars(begin, end, value);

            if (ec != std::errc{}) {
                throw tsv::parse_error{
                    ec == std::errc::result_out_of_range
                        ? tsv::parse_error::out_of_range
                        : tsv::parse_error::unknown
                };
            }

            if (remain != end) {
                throw tsv::parse_error{tsv::parse_error::leftover};
            }

            return value;
        }
    };

    /**
     * Single-character token.
     */
    template<>
    struct default_conversion<char, void>
    {
        static char parse(std::string_view text)
        {
            if (text.size() != 1) {
                throw tsv::parse_error{tsv::parse_error::unknown};
            }
            return text.front();
        }
    };

    /**
     * String token.
     */
    template<>
    struct default_conversion<std::string, void>
    {
        static std::string parse(std::string_view text)
        {
            return std::string{text};
        }
    };
}

namespace tsv
{
    template<typename T>
    struct conversion : detail::default_conversion<T> {};
}

// Parsing

namespace tsv::detail
{
    /**
     * Parses a value of type T from a string.
     */
    template<typename T>
    inline T parse(std::string_view text)
    {
        return tsv::conversion<T>::parse(text);
    }

    /**
     * Splits a string and consumes the splitted part.
     *
     * @param text  String to split. The string will be trimmed up to the
     *   first occurrence of the delimiter (or the end).
     * @param delim  Delimiter character.
     *
     * @returns The substring of `text` that precedes the first occurence
     *   of `delim`. Returns the entire input string if delim is not in the
     *   input string.
     */
    inline
    std::string_view split_consume(std::string_view& text, char delim)
    {
        if (text.empty()) {
            throw tsv::format_error{tsv::format_error::missing_field};
        }

        auto const pos = text.find(delim);
        if (pos != std::string_view::npos) {
            auto const token = text.substr(0, pos);
            text = text.substr(pos + 1);
            return token;
        } else {
            auto const token = text;
            text = text.substr(text.size());
            return token;
        }
    }

    /**
     * Parses a structure out of a tab-delimited text string. Record is the
     * type of the structure to return and Ts... is the list of field types.
     */
    template<typename Record, typename... Ts>
    Record parse_record(std::string_view text, detail::type_list<Ts...>)
    {
        Record record = {
            detail::parse<Ts>(detail::split_consume(text, '\t'))...
        };
        if (!text.empty()) {
            throw tsv::format_error{tsv::format_error::excess_field};
        }
        return record;
    }
}

// Validation

namespace tsv::detail
{
    /** Validates the values assigned to the fields of a record. */
    template<
        typename Record,
        typename = decltype(std::declval<Record&>().validate())
    >
    void validate(Record& record)
    {
        record.validate();
    }

    template<typename Record, typename... Dummy>
    void validate(Record&, Dummy...)
    {
    }
}

namespace tsv
{
    template<typename Record>
    std::vector<Record> load(std::istream& input)
    {
        std::vector<Record> records;
        std::string line;
        std::size_t line_number = 0;

        try {
            detail::field_type_list<Record> field_types;

            while (std::getline(input, line)) {
                line_number++;
                auto record = detail::parse_record<Record>(line, field_types);
                detail::validate(record);
                records.push_back(std::move(record));
            }

            if (!input.eof()) {
                throw tsv::io_error{tsv::io_error::unknown};
            }
        } catch (tsv::error& err) {
            err.line = std::move(line);
            err.line_number = line_number;
            throw;
        }

        return records;
    }
}

#endif
