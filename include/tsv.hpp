// Copyright snsinfu 2021.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef INCLUDED_SNSINFU_TSV_HPP
#define INCLUDED_SNSINFU_TSV_HPP

#include <charconv>
#include <cstddef>
#include <istream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <type_traits>
#include <utility>
#include <vector>


// Macro used to probe structure fields.

#define TSV_REPEAT_FOR_FIELDS(CLAUSE, X) \
    CLAUSE(1, X(1)) \
    CLAUSE(2, X(1), X(2)) \
    CLAUSE(3, X(1), X(2), X(3)) \
    CLAUSE(4, X(1), X(2), X(3), X(4)) \
    CLAUSE(5, X(1), X(2), X(3), X(4), X(5)) \
    CLAUSE(6, X(1), X(2), X(3), X(4), X(5), X(6)) \
    CLAUSE(7, X(1), X(2), X(3), X(4), X(5), X(6), X(7)) \
    CLAUSE(8, X(1), X(2), X(3), X(4), X(5), X(6), X(7), X(8)) \
    CLAUSE(9, X(1), X(2), X(3), X(4), X(5), X(6), X(7), X(8), X(9)) \
    CLAUSE(10, X(1), X(2), X(3), X(4), X(5), X(6), X(7), X(8), X(9), X(10))

#define TSV_MAX_FIELDS 10


namespace tsv
{
    /**
     * Loads tab-separated values from each line of an input.
     *
     * @param input is a stream containing a tab-separated document.
     *
     * @returns A vector of loaded records.
     */
    template<typename Record>
    std::vector<Record> load(std::istream& input);

    template<typename Record>
    std::vector<Record> load(std::istream&& input)
    {
        return tsv::load<Record>(input);
    }

    /**
     * Base class for reporting an error when parsing an input.
     */
    class error : public std::runtime_error
    {
    public:
        using std::runtime_error::runtime_error;

        /**
         * Content of the line that caused the error, if available.
         */
        std::string line;

        /**
         * 1-based line number in an input where the error is occured. This is
         * set to zero if a line number is not available.
         */
        std::size_t line_number = 0;

        /**
         * Describes the error in detail. This function allocates memory and
         * thus can throw an exception.
         */
        std::string describe() const
        {
            std::string message = what();

            if (line_number) {
                message += " (at line ";
                message += std::to_string(line_number);
                message += ")";
            }

            if (!line.empty()) {
                message += ": \"";
                message += line;
                message += "\"";
            }

            return message;
        }
    };

    /**
     * An exception thrown when an input line has unexpected number of fields.
     */
    class format_error : public tsv::error
    {
    public:
        using tsv::error::error;

        static inline char const* const missing_field =
            "insufficient number of fields";
        static inline char const* const excess_field =
            "excess fields";
    };

    /**
     * An exception thrown when a text is not parseable as a value.
     */
    class parse_error : public tsv::error
    {
    public:
        using tsv::error::error;

        static inline char const* const unknown =
            "parse error";
        static inline char const* const out_of_range =
            "value out of range";
        static inline char const* const leftover =
            "excess character(s) at the end of a field";
    };

    /**
     * An exception thrown when reading from an input fails.
     */
    class io_error : public tsv::error
    {
    public:
        using tsv::error::error;

        static inline char const* const unknown =
            "input error";
    };

    /**
     * An exception thrown when validation fails on a record.
     */
    class validation_error : public tsv::error
    {
    public:
        using tsv::error::error;
    };

    /**
     * Throws `tsv::validation_error` if a predicate is false.
     *
     * Use `tsv::check()` function to validate the values of the fields in your
     * record structure in `validate()` member function.
     *
     * ```
     * struct my_record
     * {
     *     unsigned row;
     *     unsigned column;
     *     double value;
     *
     *     void validate() const
     *     {
     *         tsv::check(
     *             row < column,
     *             "row index must be smaller than column index"
     *         );
     *         tsv::check(value >= 0, "value must be non-negative);
     *     }
     * };
     * ```
     *
     * @param pred  The condition to test.
     * @param message  A message that describes the expected condition.
     */
    inline
    void check(bool pred, std::string const& message)
    {
        if (!pred) {
            throw tsv::validation_error{message};
        }
    }

    /**
     * Traits class for customizing how values of type T are parsed.
     */
    template<typename T>
    struct conversion;
}

// Structure member counting

namespace tsv::detail
{

    /**
     * Dummy class used for ordering SFINAE overloads.
     *
     * We probe a structure type with aggregate initialization using varying
     * number of fields in the initializer. However, the probing is not
     * sufficient to determine the number of fields. For example, if R is
     * a structure of three fields, `R{a}`, `R{a,b}` and `R{a,b,c}` are
     * all valid initializations. We would like to order probes so that
     * `R{a,b,c}` is preferred. To that end, we exploit an order induced
     * by upcasting of a class object in function arguments.
     */
    template<std::size_t N>
    class rank : public rank<N - 1> {};

    template<>
    class rank<0> {};

    using max_rank = rank<TSV_MAX_FIELDS>;

    /**
     * Dummy convertible-to-anything type used to probe structure fields.
     */
    struct any
    {
        template<typename T>
        operator T() const;
    };

    // Generate probe() function overloads.

#define CLAUSE(N, ...)                                        \
    template<typename R, typename = decltype(R{__VA_ARGS__})> \
    std::integral_constant<std::size_t, N> probe(detail::rank<N> const&);
#define X(I) detail::any{}

    TSV_REPEAT_FOR_FIELDS(CLAUSE, X)

#undef CLAUSE
#undef X

    /**
     * Detects the number of fields in an aggregate structure.
     */
    template<typename Record>
    using record_size = decltype(detail::probe<Record>(detail::max_rank{}));
}

// Structure decomposition

namespace tsv::detail
{
    /**
     * A dummy type to hold a template type list.
     */
    template<typename...>
    struct type_list {};

    template<typename... Ts>
    detail::type_list<Ts...> type_list_of(Ts const&...);

    // Generate decompose() function overloads.

#define CLAUSE(N, ...)                                                      \
    template<typename R>                                                    \
    auto decompose(R const& record, std::integral_constant<std::size_t, N>) \
    {                                                                       \
        auto [__VA_ARGS__] = record;                                        \
        return detail::type_list_of(__VA_ARGS__);                           \
    }
#define X(I) a##I

        TSV_REPEAT_FOR_FIELDS(CLAUSE, X)

#undef CLAUSE
#undef X

    /**
     * Returns a `type_list` of the non-static member variables in an
     * aggregate structure.
     */
    template<typename Record>
    using field_type_list = decltype(
        detail::decompose(
            std::declval<Record>(), detail::record_size<Record>{}
        )
    );
}

namespace tsv::detail
{
    // Basic value parsing

    /**
     * Default implementation for tsv::conversion traits defined below.
     *
     * Fallback uses stream input operator to read a value of type T from
     * a stringstream. This is slow.
     */
    template<typename T, typename = void>
    struct default_conversion
    {
        static T parse(std::string_view text)
        {
            using char_traits = std::istringstream::traits_type;

            std::istringstream stream{std::string{text}};
            T value;
            stream >> value;

            if (stream.fail() && !stream.eof()) {
                throw tsv::parse_error{tsv::parse_error::unknown};
            }

            if (stream.get() != char_traits::eof()) {
                throw tsv::parse_error{tsv::parse_error::leftover};
            }

            return value;
        }
    };

    /**
     * An optimized implementation of `default_conversion` for numeric
     * types T.
     */
    template<typename T>
    struct default_conversion<
        T,
        std::void_t<
            decltype(std::from_chars(nullptr, nullptr, std::declval<T&>()))
        >
    >
    {
        static T parse(std::string_view text)
        {
            auto const begin = text.data();
            auto const end = text.data() + text.size();

            T value;
            auto const [remain, ec] = std::from_chars(begin, end, value);

            if (ec != std::errc{}) {
                throw tsv::parse_error{
                    ec == std::errc::result_out_of_range
                        ? tsv::parse_error::out_of_range
                        : tsv::parse_error::unknown
                };
            }

            if (remain != end) {
                throw tsv::parse_error{tsv::parse_error::leftover};
            }

            return value;
        }
    };

    /**
     * Single-character token.
     */
    template<>
    struct default_conversion<char, void>
    {
        static char parse(std::string_view text)
        {
            if (text.size() != 1) {
                throw tsv::parse_error{tsv::parse_error::unknown};
            }
            return text.front();
        }
    };

    /**
     * String token.
     */
    template<>
    struct default_conversion<std::string, void>
    {
        static std::string parse(std::string_view text)
        {
            return std::string{text};
        }
    };
}

namespace tsv
{
    template<typename T>
    struct conversion : detail::default_conversion<T> {};
}

// Parsing

namespace tsv::detail
{
    /**
     * Parses a value of type T from a string.
     */
    template<typename T>
    T parse(std::string_view text)
    {
        tsv::conversion<T> conv;
        return conv.parse(text);
    }

    /**
     * Splits a string and consumes the splitted part.
     *
     * @param text  String to split. The string will be trimmed up to the
     *   first occurrence of the delimiter (or the end).
     * @param delim  Delimiter character.
     *
     * @returns The substring of `text` that precedes the first occurence
     *   of `delim`. Returns the entire input string if delim is not in the
     *   input string.
     */
    inline
    std::string_view split_consume(std::string_view& text, char delim)
    {
        if (text.empty()) {
            throw tsv::format_error{tsv::format_error::missing_field};
        }

        auto const pos = text.find(delim);
        if (pos != std::string_view::npos) {
            auto const token = text.substr(0, pos);
            text = text.substr(pos + 1);
            return token;
        } else {
            auto const token = text;
            text = text.substr(text.size());
            return token;
        }
    }

    /**
     * Parses a structure out of a tab-delimited text string. Record is the
     * type of the structure to return and Ts... is the list of field types.
     */
    template<typename Record, typename... Ts>
    Record parse_record(std::string_view text, detail::type_list<Ts...>)
    {
        Record record = {
            detail::parse<Ts>(detail::split_consume(text, '\t'))...
        };
        if (!text.empty()) {
            throw tsv::format_error{tsv::format_error::excess_field};
        }
        return record;
    }
}

// Validation

namespace tsv::detail
{
    /**
     * Validates the values assigned to the fields of a record.
     */
    template<
        typename Record,
        typename = decltype(std::declval<Record&>().validate())
    >
    void validate(Record& record)
    {
        record.validate();
    }

    template<typename Record, typename... Dummy>
    void validate(Record&, Dummy...)
    {
    }
}

namespace tsv
{
    template<typename Record>
    std::vector<Record> load(std::istream& input)
    {
        std::vector<Record> records;
        std::string line;
        std::size_t line_number = 0;

        try {
            detail::field_type_list<Record> field_types;

            while (std::getline(input, line)) {
                line_number++;
                auto record = detail::parse_record<Record>(line, field_types);
                detail::validate(record);
                records.push_back(std::move(record));
            }

            if (!input.eof()) {
                throw tsv::io_error{tsv::io_error::unknown};
            }
        } catch (tsv::error& err) {
            err.line = std::move(line);
            err.line_number = line_number;
            throw;
        }

        return records;
    }
}

#undef TSV_REPEAT_FOR_FIELDS

#endif
